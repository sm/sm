#!/usr/bin/env bash

fetch_version()
{
  version=$(curl -B "${releases_url}/latest-version.txt" 2>/dev/null)
}

fetch_md5()
{
  md5=$(curl -B "${releases_url}/bdsm-${version}.tar.gz.md5" 2>/dev/null)
}

md5_match()
{
  local archive="$1"

  case "$(uname)" in
    Darwin|FreeBSD)
      archive_md5="$(/sbin/md5 -q "${archive}")"
      ;;

    OpenBSD)
      archive_md5="$(/bin/md5 -q "${archive}")"
      ;;

    Linux|*)
      archive_md5="$(md5sum "${archive}" | awk '{print $1}')"
      ;;
  esac

  if [[ "$archive_md5" == "$md5" ]]
  then
    return 0
  else
    return 1
  fi
}

fetch_extensions_git_repository()
{
  local initial_pwd="$PWD" _identifier _url="${1:-${extensions_repository_url}}"

  # Convert '/' to an invalid url component '_'
  _identifier="${_url//\//_}"

  if path_exists "$extensions_src_path/${_identifier}/.git"
  then
    log "# Updating repository from ${_url}"
    if scm_update "${_url}"
    then
      if path_exists "${extensions_src_path}/${_identifier}"
      then
        remove_paths "${extensions_src_path}/${_identifier}"
      fi
      copy_paths "${repos_path}/${_identifier}/" \
        to "${extensions_src_path}"
    else
      error "There was an error updating the repository."
    fi
  else
    log "Cloning $extension repository from ${_url}"

    scm_fetch "${_url}"

    if path_exists "${extensions_src_path}/${_identifier}"
    then
      remove_paths "${extensions_src_path}/${_identifier}"
    fi
    copy_paths "${repos_path}/${_identifier}/" \
      to "${extensions_src_path}"
  fi

  enter "$initial_pwd"
}

fetch_tarball()
{
  curl \
    -L "${releases_url}/${extension}-${extension_version}.tar.bz2" \
    -o "${extensions_src_path}/${extension}-${extension_version}.tar.bz2"

  # TODO: md5 check using fetch_md5() and md5_match()

  tar \
    xf "${extensions_src_path}/${extension_version}.tar.bz2" \
    -C "${extensions_src_path}/extensions"

  enter "${extensions_src_path}/${extension}-${extension_version}"
}

#
# Package given extension.
#
package_extension()
{
  local sha1="" version

  extension_path="${extensions_path}/${extension}"

  if !read -r version < "$extension_path/VERSION"
  then
    fail "${extension_path}/VERSION file is missing. Halting packaging."
  fi

  # TODO: add a sanity check to ensure that VERSION matches x.y.x

  true ${releases_path:="${source_path}/bdsm-extensions/releases"}

  true \
    ${release_name:="${extension}-${version}"} \
    ${release_path:="${releases_path}/${release_name}"} \
    ${remote:=origin} \
    ${branch:=master}

  ensure_paths_exist "$releases_path/" "$release_path/"

  enter "${extension_path}"

  if [[ -d ".git" ]]
  then
    sha1=$(git log -n 1 | head -1 | awk '{print $2}')

    # Tag & push
    git tag "${version}"
    git push "${remote}" "${version}"
    git push "${remote}" "${branch}"
  fi

  release_files=(VERSION README.md)

  for file in "${release_files[@]}"
  do
    if [[ -f "${file}" ]]
    then
      cp -f "${file}" "${release_path}/"
    else
      log "WARNING: Missing extension file: '${file}'"
    fi
  done

  release_directories=(bin config modules templates)

  for directory in "${release_directories[@]}"
  do
    if path_exists "${directory}"
    then
      cp -Rf "${directory}" "${release_path}/"
    else
      log "WARNING: Missing extension directory: '${directory}'"
    fi
  done

  if variable_is_nonempty sha1
  then
    echo "${sha1:0:7}" > "${release_path}/sha1"
  fi

  enter "$releases_path"

  tar zcvf "$release_name".tar.gz "$release_name/"
  file_md5 "${release_name}.tar.gz" > "${release_name}.tar.gz.md5"

  tar jcvf "$release_name".tar.bz2 "$release_name/"
  file_md5 "${release_name}.tar.bz2" > "${release_name}.tar.bz2.md5"

  remove_paths "${release_name}/"

  log "Packaging of extension ${release_name} complete."
}

get_help()
{
  cat -v "$help_path/get"
}

#
# TODO: There is a lot of redundency in the get_{X}(), reduce it.
#
get_latest()
{
  local version_url stable_version archive

  version_url="${releases_url}/version.txt"

  stable_version=$(curl -s $version_url)

  ensure_paths_exist "$src_path/"

  # NOTE: This is the content as in binmodules/bdsm-update-latest

  version=$(curl -B $version_url 2>/dev/null)

  get_version $stable_version
}

get_version()
{
  version="$1"

  md5=$(
  curl -B http://bdsm.beginrescueend.com/releases/bdsm-${version}.tar.gz.md5 \
    2>/dev/null
  )

  echo "bdsm-${version}"

  archive="$archives_path/bdsm-${version}.tar.gz"

  curl -L "http://bdsm.beginrescueend.com/releases/bdsm-${version}.tar.gz" \
    -o "$archive"
  case "$(uname)" in
    Darwin|FreeBSD)
      archive_md5="$(/sbin/md5 -q "${archive}")"
      ;;
    OpenBSD)
      archive_md5="$(/bin/md5 -q "${archive}")"
      ;;
    Linux|*)
      archive_md5="$(md5sum "${archive}" | awk '{print $1}')"
      ;;
  esac

  if [[ "$archive_md5" != "$md5" ]]
  then
    error "Archive package bdsm-${version}.tar.gz downloaded does not "\
      "match it's md5 checksum ${md5}." \
      "Aborting BDSM Installation."
  fi

  tar zxf "${path}/archives/bdsm-${version}.tar.gz" -C "$extensions_src_path/"

  (
  cd "$src_path/bdsm-${version}"
  chmod +x ./install
  ./install
  )

  log "Installed BDSM version:"
  (
  source $modules_path/bdsm
  bdsm --version
  )

  hook="after_update"

  source "$modules_path/hook"
}

get_branch()
{
  local clone=1
  (
  if path_exists "${extensions_src_path}/bdsm/.git"
  then
    enter "${extensions_src_path}/bdsm"
    git fetch ${remote}
    if git pull --rebase --force ${remote} ${branch}
    then
      clone=0
    else
      enter "${extensions_src_path}"
      remove_paths "${extensions_src_path}/bdsm"
    fi
  else
    (
    if ! git clone --depth 1 ${extensions_repository_url}
    then # reattempt replacing the url scheme.
      git clone ${extensions_repository_url/git:\/\//https://}
    fi
    )
    enter "bdsm"
  fi

  chmod_files 0755 "install"

  ./install
  )
}

extension_cli()
{
  local _ignored_args=() _string

  number_of_args=${#extension_args[@]}

  for (( index=0 ; index < $number_of_args ; index++ ))
  do
    token="${extension_args[$index]}"

    case "$token" in
      --uri|--url)
        extension_uri="${extension_args[$((++index))]}"
        ;;
      --version)
        extension_version="${extension_args[$((++index))]}"
        ;;
      --archive_format)
        archive_format="${extension_args[$((++index))]}"
        ;;
      --licence)
        extension_license
        exit 0
        ;;
      --modules)
        _string="${extension_args[$((++index))]}"
        extension_modules=(${_string//,/ })
        ;;
      --help)
        extension_action "ext" "help"
        exit 0
        ;;
      --trace)
        set -o xtrace
        ;;
      *)
        _ignored_args+=("${token}")
        ;;
    esac
  done

  if array_is_nonempty _ignored_args
  then
    extension_args=( "${_ignored_args[@]}" )
  fi
}
