#!/usr/bin/env bash

# detect_action $extension action extension_args "${extension_args[@]}"
detect_action()
{
  extensions_path=$1
  shift
  extension="${1:-core}"
  shift

  local token _word _action_path=("$extensions_path/$extension/actions")

  local _params=("$@")

  #loop when params or .actions exists
  while [[ ${#_params[@]} -gt 0 ]] || file_exists "$(path_join "${_action_path[@]}" .actions)"
  do
    array_shift _params token

    # Detect function
    if  variable_is_nonempty token &&
      match "$token" "*\(\)"
    then
      _params=( "${token}" "${_params[@]}" )
      break

    # Detect a namespace
    elif variable_is_nonempty token &&
      path_exists "$(path_join "${_action_path[@]}" $token)"
    then
      _action_path+=("${token}")

    # Detect mapping in .actions
    elif file_exists "$(path_join "${_action_path[@]}" .actions)" &&
         file_contains "$(path_join "${_action_path[@]}" .actions)" "^${token}="
    then
      _array=( $(hash_file "$(path_join "${_action_path[@]}" .actions)" ${token}) )
      _params=( "${_array[@]}" "${_params[@]}" )
      [[ "${_array[@]}" == "$token" ]] && break #break if detected 2nd time the same

    # Detect default mapping in .actions
    elif file_exists "$(path_join "${_action_path[@]}" .actions)" &&
         file_contains "$(path_join "${_action_path[@]}" .actions)" "^default="
    then
      _array=( $(hash_file "$(path_join "${_action_path[@]}" .actions)" default) )
      _params=( "${_array[@]}" "${_params[@]}" )
      [[ "${_array[@]}" == "$token" ]] && break #break if detected 2nd time the same

    # Detect help mapping in .actions
    elif file_exists "$(path_join "${_action_path[@]}" .actions)" &&
         file_contains "$(path_join "${_action_path[@]}" .actions)" "^help="
    then
      _array=( $(hash_file "$(path_join "${_action_path[@]}" .actions)" help) )
      _params=( "${_array[@]}" "${_params[@]}" )
      [[ "${_array[@]}" == "$token" ]] && break #break if detected 2nd time the same

    # finish searching path
    else
      _params=( "${token}" "${_params[@]}" )
      break
    fi
  done

  if array_is_empty _params
  then
    token=""
  else
    array_shift _params token
  fi

  # Detect function
  if variable_is_nonempty token &&
    match "${token}" "*\(\)"
  then
    action_path=$(path_join "${_action_path[@]}")
    action="$token"
    extension_args=( "${_params[@]}" )

  # Detect a file
  elif variable_is_nonempty token &&
    file_is_executable "$(path_join "${_action_path[@]}" ${token})"
  then
    action_path=$(path_join "${_action_path[@]}")
    action="$token"
    extension_args=( "${_params[@]}" )

  # Detect default if nothing else matches
  elif file_exists "$(path_join "${_action_path[@]}" default)"
  then
    action_path=$(path_join "${_action_path[@]}")
    action="default"
    extension_args=( "$token" "${_params[@]}" )

  # Detect help if no default
  elif file_exists "$(path_join "${_action_path[@]}" help)"
  then
    action_path=$(path_join "${_action_path[@]}")
    action="help"
    [[ "$token" != "" ]] && extension_args=("$token") || extension_args=()
    extension_args+=( "${_params[@]}" )

  else
    # Not found, error.
    return 1
  fi

  # Found, OK
  return 0
}

detect_action_type()
{
  local _path="${action_path:-}"

  case "${action}" in
    (*\(\))
      action_type="function"
      return 0
      ;;
    *)
      _path_type="$(file "${_path}/${action}")"
      ;;
  esac

  case "${_path_type}" in

    *sh[[:space:]]script*|*POSIX[[:space:]]shell*|*Bourne-Again*)
      action_type="shell"
      ;;

    *ASCII*)
      # Launch with helper dsl, if possible.
      extension="${_path//.}"

      case "${extension}" in
        shell|zsh|bash|sh)
          action_type="shell"
          #rb) action_type="ruby"   ;;
          ;;
        *)
          read -r shebang < "${_path}"

          case "${shebang}" in
            *ruby|*rbx|*jruby|*macruby)
              binary="${shebang##*(#|!)}"
              binary="${binary##* }"
              action_type="ruby"
              ;;
            *)
              if [[ -x "${_path}" ]] ; then
                action_type="binary"
              else
                action_type="not executable"
              fi
              ;;
          esac
          ;;
      esac
      result=$?
      ;;

    cannot[[:space:]]open)
      action_type="dne"
      ;;

    *)
      if file_is_executable "${_path}"
      then
        action_type="binary"
      else
        action_type="noexec"
      fi
      ;;
  esac

  return $?
}

extension_modules_load()
{
  local _token _namespace=()

  # Load the extensions's core module
  source_files \
    "${extension_modules_path}/shell/dsl" \
    "${extension_modules_path}/shell/initialize" \
    "${extension_modules_path}/shell/cli"

  while (( $# > 0 ))
  do
    _namespace+=("${1}")
    shift

    namespace="$(path_join ${_namespace[*]})"

    source_files \
      "${extension_modules_path}/shell/${namespace}/dsl" \
      "${extension_modules_path}/shell/${namespace}/initialize" \
      "${extension_modules_path}/shell/${namespace}/cli"
  done
}

extension_run()
{
  local _type="${action_type:-}" _path="${action_path:-}" _namespaces

  # Now based on the determined _type we launch the extension.
  case "${_type}" in
    function)
      (
      enable_backtrace
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      if command_exists "${action##_*}_cli"
      then
        "${action##_*}_cli"
      fi

      ${action%%(*}

      ) || result=$?
      return $result
      ;;

    shell)
      (
      enable_backtrace
      if [[ "${action##*/}" == help ]]
      then # Load the help module also.
        modules core help
      else
        modules core
      fi
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }
      . "${_path}/${action}"
      ) || result=$?
      return $result
      ;;

    ruby)
      requires=()
      for script in dsl initialize
      do
        requires+=( "-r${modules_path}/ruby/core/${script}.rb" )
      done

      "${binary:-ruby}" -I"${modules_path}/ruby" -I"${extension_modules_path}/ruby" \
        ${requires[@]} "${_path}/${action}"
      ;;
    # python|lua|javascript)
      #   ADD "${modules_path}/${_type}/" to the lib path so the script can require "bdsm"
      #  "${_path}"
      #  ;;
    dne|noexec)
      fail "Processing ${action} failed, file type is unknown, file does not exist or file is not executable."
      ;;
    binary|*)
      "${_path}/${action}" ${extension_action} ${extension_args[*]}
      ;;
  esac || result=$?

  return $result
}

extensions_search_paths()
{
  printf "${parent_extensions_path}/external ${parent_extensions_path}/internal ${parent_extensions_path}/builtin"
}

detect_action_in_paths()
{
  local search_paths=( $(extensions_search_paths) )
  local builtin_path="${parent_extensions_path}/builtin"
  local builtin_extensions=( $(cd "${builtin_path}" ; echo -n * ) )

  for path in "${search_paths[@]}"
  do
    if detect_action "${path}" "${extension_args[@]}"
    then
      return 0
    fi
  done

  for builtin_extension in "${builtin_extensions[@]}"
  do
    if detect_action "${builtin_path}" "${builtin_extension}" "${extension_args[@]}"
    then
      return 0
    fi
  done

  return 1
}

#
# ## extension\_action()
#
# Load the environment for a given extension action and then call it.
# This is the main function for BDSM.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success
# 1 for failure
#
# ### Failure Scenarios
#
# Fails if no extension was given.
# Fails if no action was given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extension_action ext list
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
#
#
extension_action()
{
  [[ extension_action_calls -gt 0 ]] && fail "can not call 2nd time\n  extension_action ${extension_args[@]}"
  extension_action_calls+=1
  unset extension action

  if detect_action_in_paths
  then
    debug "detected path:$action_path, action:$action, params:${extension_args[@]}."
  else
    fail "Usage: \n  bdsm ${extension} [namespace] [action]\nActions:\n   $(extension_actions "${extension}")"
  fi

  extension_path="$extensions_path/$extension"
  extension_config_path="$extension_path/config"
  extension_templates_path="$extension_path/templates"
  extension_modules_path="$extension_path/modules"
  extension_actions_path="$extension_path/actions"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  enter "${extension_path}"
  bdsm_exports
  detect_action_type
  extension_run
}

#
# ## extension\_reload()
#
# Reloads (re-sources) the current extension's DSL and initialization files.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's DSL and initialization files are re-sourced into the
# calling environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No current failure scenarios.
#
# ### Usage Examples
#
#     user$ extension_reload
#
extension_reload()
{
  local _path="${extension_modules_path}/shell"

  source_files "${_path}/dsl" "${_path}/initialize"
}

#
# ## extension\_reinitialize()
#
# Reinitializes the current extension.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ extension_reinitialize
#
extension_reinitialize()
{
  local _path="${extension_modules_path}/shell"

  source_files "${_path}/initialize"
}

#
# ## extension\_version()
#
# Outputs the named extension's version
#
# ### Input Parameters
#
# First parameter must be the name of an extension.
#
# ### Stream Outputs
#
# The extension-version string for the named extension.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if the extension name is not given.
#
# ### Usage Examples
#
#     user$ extension_reinitialize
#
extension_version()
{
  local _extension="${1:-}"

  if variable_is_nonempty _extension
  then
    shift
    true ${extension_path:="${extensions_path}/${_extension}"}

    if file_exists "${extension_path}/VERSION"
    then
      read -r extension_version < "${extension_path}/VERSION"
    else
      extension_version="head"
    fi

    log "${extension}-${extension_version}"
  else
    fail "Can not retrieve extension version as no extension was given."
  fi
}

#
# ## extension\_licence()
#
# Emits the extension's license file, if it exists.
#
# ### Input Parameters
#
# First parameter may optionally be an extension name.
#
# ### Stream Outputs
#
# If the extension has a LICENSE file then it wil be printed to STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently exist.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     !/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extension_license postgresql
#
#     $ $HOME/test
#     Copyright (c) 2009-2011 Wayne E. Seguin
#
#     Licensed under the Apache License, Version 2.0 (the \"License\");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an \"AS IS\" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
extension_license()
{
  local _extension="${1:-${extension}}"

  if variable_is_nonempty _extension
  then
    cat -v "${extensions_path}/${_extension}/LICENSE"
  else
    fail "Can not display extension license as an extension was not given."
  fi
}

#
# ## extensions\_installed()
#
# Lists the extensions installed on the currently running process's system.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the currently installed non-core extensions are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_installed
#
#     $ $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
#
extensions_installed()
{
  extensions_in "$1"
}

#
# ## extensions\_available()
#
# Lists the extensions available to install on the currently running process's
# system.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the available to install non-core extensions are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extensions_available

#      $  $HOME/test
#      ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
#
extensions_available()
{
  extensions_in "${extensions_src_path}"
}

#
# ## extensions\_in\_development()
#
# Lists the extensions available in the development repository, if set.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the available to install non-core development repository
# extensions are printed to the calling environment's STDOUT, if defined.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extensions_in_development

#      $  $HOME/test
#      ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
#
extensions_in_development()
{
  true "${extensions_development_path:="${extensions_src_path}"}"

  list_extensions_in "${extensions_development_path}"
}

#
# ## extensions\_in()
#
# Lists the extensions in a given directory.
#
# ### Input Parameters
#
# First parameter is a full path a BDSM extensions directory.
#   (example: /usr/local/bdsm/extensions)
#
# ### Stream Outputs
#
# The names of the extensions in the given directory are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_in /usr/local/bdsm/extensions
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
#
#
extensions_in()
{
  local _path="${1:-}"

  if path_exists "${_path}"
  then
    _files=($(
    find "${_path}" -mindepth 2 -maxdepth 2 -name 'VERSION' -type f
    ))
    extensions=()

    for _file in "${_files[@]}"
    do
      extension_source_path="${_file/%\/VERSION}"
      extension_name="${extension_source_path//*\/}"
      extensions[${#extensions[@]}]="${extension_name//*\//}"
    done

    extensions="${extensions[@]}"

    printf "${extensions}"
  else
    fail "Cannot list extensions in '${_path}' as the directory does not exist."
  fi
}

#
# ## extension\_actions()
#
# Lists actions exposed by the named extension.
#
# ### Input Parameters
#
# First parameter is the name of the extension to list actions for.
#
# ### Stream Outputs
#
# The names of the extensions in the given directory are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no extension name is given.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extension_actions "postgresql"
#
#      $ $HOME/test
#      backup configure help initialize install restart start status stop uninstall upgrade
#
#
#
extension_actions()
{
  local _extension="${1:-}" _files _file _actions=()

  if variable_is_nonempty _extension
  then
    if path_exists "${extension_actions_path}"
    then
      _files=($(
      find "${extension_actions_path}" -mindepth 1 -type f -perm -o+rx
      ))

      for _file in "${_files[@]}"
      do
        _actions+=("${_file#${extension_actions_path}}")
      done
      _actions="${_actions[@]}" # Convert from array to string.
      printf "${_actions}"
    else
      return 0
    fi
  else
    fail "Cannot list actions for extension as no extension was given."
  fi
}

#
# ## extension\_is\_installed()
#
# Tests if a given extension is installed.
#
# ### Input Parameters
#
# First parameter is an extension name.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the extension is installed.
# 1 if the extension is not installed.
#
# ### Failure Scenarios
#
# Fails if no extension name is given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_installed
#     echo
#     for extension in postgresql asdf
#     do
#       if extension_is_installed "${extension}"
#       then
#         echo "${extension} is installed! "
#       else
#         echo "${extension} is NOT installed! "
#       fi
#     done
#
#     $  $HOME/test
#     bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
#     postgresql is installed!
#     asdf is NOT installed!
#
extension_is_installed()
{
  local _name="${1:-}"

  if [[ -n "${_name}" ]]
  then
    local _extensions=" $(extensions_in "${extensions_path}") "

    case "${_extensions}" in
      (*[[:space:]]${_name}[[:space:]]*)
        return 0
        ;;
      (*)
        return 1
        ;;
    esac
  else
    fail "Can not check for an installed extension as no extension name was given."
  fi
}

#
# ## extension\_install()
#
# Installs the given external extension.
#
# ### Input Parameters
#
# First parameter is the name of the extension to install
# Second parameter is the src_path of the extension to install
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The named extension will be installed to the filesystem in the BDSM
# external extension directory.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no extension are passed in to install.
#
# ### Usage Examples
#
#     user$ extension_install backup mpapis_bdsm_backup
#
extension_install()
{
  local _extension="${1:-}" _src
  _src="${2:-${_extension}}"

  if variable_is_nonempty _extension
  then
    if extension_is_valid "${extensions_src_path}/${_src}"
    then
      log " - ${_extension}"
      if path_exists "${bdsm_path}/extensions/external/${_extension}"
      then
        remove_paths "${bdsm_path}/extensions/external/${_extension}"
      fi

      copy_directory "${extensions_src_path}/${_src}" \
        to "${bdsm_path}/extensions/external/${_extension}"

      log "${extension_uri}" to "${bdsm_path}/extensions/external/${_extension}/.uri"

      #
      # TODO: Process extension dependencies...
      #
    else
      error "${extensions_src_path}/${_src} is not a valid extension"\
        "as it is missing VERSION and/or actions/help files."
    fi
  else
    fail "Cannot install an extension as no extension name was given."
  fi
}

extension_is_valid()
{
  local _path="${1:-}"

  if variable_is_nonempty _path
  then
    # TODO: Add all extension requirement checks here.
    if [[ -s "${_path}/VERSION" && -x "${_path}/actions/help" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot determine if an extension is valid as the path to the extension was not given."
  fi
}

extension_package()
{
  local _name="${1:-}" _path _version file

  if [[ -n "${_name}" ]]
  then
    _path="${extensions_development_path:-"$extensions_src_path"}"

    enter "${_path}"

    if extension_is_valid "${_path}/${_name}"
    then
      _version="$(cat "${_name}/VERSION")"
      log "Packaging extension ${_name}"
      log "${_name}-${_version}:"

      for archiver in "gzip" "bzip2 -z" "xz -z"
      do
        if command_exists ${archiver// *}
        then
          if tar cf "${_name}-${_version}.tar" "${_name}/"
          then
            ${archiver} -f -9 "${_name}-${_version}.tar"
          else
            error "There was an error ($?) while trying to create a tar of the '${_name}' directory while packaging."
          fi
        fi

        ensure_paths_exist "${_path}/pkg"

        for file in "${_name}-${_version}".tar.*
        do
          log "  - ${file}"
          log "$( file_md5 "${file}" )" to "${file}.md5"
          log "  - ${file}.md5"
          move_files --force "${file}" "${file}.md5" \
            to "${_path}/pkg" from "${_path}"
        done
      done
      log "Packaging complete (packages are located in '${_path}/pkg' )"
    else
      error "Cannot package extension '${_name}' as the extension is not valid."
    fi
  else
    fail "Cannot package an extension as no extension name was given."
  fi
}

extension_publish()
{
  local _name="${1:-}" _path _version

  NIY "Extension publishing to extensions.beginrescueend.com has not yet been implemented."

  if [[ -n "${_name}" ]]
  then
    _path="${extensions_development_path:-"$extensions_src_path"}"

    enter "${_path}"

    if extension_is_valid "${_path}/${_name}"
    then
      _version="$(cat "${_name}/VERSION")"
      log "Packaging extension ${_name}"
      log "${_name}-${_version}:"

      for formats in ".tar.gz" ".tar.bz2" ".tar.xz"
      do
        if path_exists "${_path}/pkg/"
        then
          log "publishing ${_name}-${_version}"

          for file in "${_pth}/${_name}-${_version}".tar.{gz,xz,bz2}
          do
            log "  - ${file}"
            log "  - ${file}.md5"
            NIY "publishing"
          done
        else
          error "The local package path '${_path}' does not exist, did you run"\
            "'extension package ${_name}' before 'extension publish ${_name}'?"
        fi
      done
      log "Packaging complete (packages are located in '${_path}/pkg' )"
    else
      error "Cannot package extension '${_name}' as the extension is not valid."
    fi
  else
    fail "Cannot publish an extension as no extension name was given."
  fi
}

extension_module_add()
{
  local _extension="${1}" _module="${2}" _path
  _path="${3:-"${extensions_development_path}/${_extension}"}"

  timestamp_set

  if file_contains "${_path}/modules/shell/initialize" "modules "
  then
    if awk "/modules /{printf \$0; print \" ${_module}\"}
      ! /modules/{print \$0}" "${_path}/modules/shell/initialize" \
        >> "${_path}/modules/shell/initialize.${timestamp}"
    then
      if move_file "${_path}/modules/shell/initialize.${timestamp}"\
        to "${_path}/modules/shell/initialize"
      then
        return 0
      else
        fail "Failed to move ${_path}/modules/shell/initialize.${timestamp}"\
          "to ${_path}/modules/shell"\
          "while adding module '${_module}'"
      fi
    else
      fail "Failed to modify ${_path}/modules/shell/initialize" \
        "when trying to add module '${_module}'"
    fi
  else
    log "modules ${_module}\n" append to "${_path}/modules/shell/initialize"
  fi
}
