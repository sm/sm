#!/usr/bin/env bash


# detect_action $extension action extension_args "${extension_args[@]}"
detect_action()
{
  local token _word

  extension="${1:=core}"
  shift

  local _params=("$@")

  local _action_path=("$extensions_path/$extension/actions")

  if array_is_empty _params
  then
    _params=("default")
  fi

  while (( ${#_params[@]} > 0 ))
  do
    array_shift _params token

    # Detect a namespace
    if path_exists "$(path_join "${_action_path[@]}" $token)"
    then
      _action_path+=("$token")
      continue

    elif match "${token}" "*\(\)"
    then
      action_path=$(array_join _action_path '/')
      action="$token"
      return 0

    # Detect a file
    elif file_is_executable "$(path_join "${_action_path[@]}" $token)"
    then
      action_path=$(array_join _action_path '/')
      action="$token"
      extension_args=("${_params[@]}")
      return 0

    elif file_exists "$(path_join "${_action_path[@]}" .actions)" &&
         file_contains "$(path_join "${_action_path[@]}" .actions)" "^${token}="
    then
      _array=($(hash_file "$(path_join "${_action_path[@]}" .actions)" $token))
      _params=(${_array[@]} ${_params[@]})
      continue

    # run default if found
    elif file_exists "$(path_join "${_action_path[@]}" default)"
    then
      action="default"
      action_path=$(array_join _action_path '/')
      extension_args=("$token")
      extension_args+=("${_params[@]}")
      return 0

    elif file_exists "$(path_join "${_action_path[@]}" .actions)" &&
         file_contains "$(path_join "${_action_path[@]}" .actions)" "^default="
    then
      _array=($(hash_file "$(path_join "${_action_path[@]}" .actions)" default))
      _params=(${_array[@]} ${_params[@]})
      continue

    # default to help if no defualt set in path
    elif file_exists "$(path_join "${_action_path[@]}" help)"
    then
      action="help"
      action_path=$(array_join _action_path '/')
      extension_args=("$token")
      extension_args+=("${_params[@]}")
      return 0

    # Not found, error.
    else
      return 1
    fi
  done
  return 1
}

detect_action_type()
{
  local _path="${1:-}" _action="${2:-}"

  case "${action}" in
    (*\(\))
      action_type="function"
      return 0
      ;;
    *)
      _path_type="$(file "${_path}/${_action}")"
      ;;
  esac

  case "${_path_type}" in

    *sh[[:space:]]script*|*POSIX[[:space:]]shell*|*Bourne-Again*)
      action_type="shell"
      ;;

    *ASCII*)
      # Launch with helper dsl, if possible.
      extension="${_path//.}"

      case "${extension}" in
        shell|zsh|bash|sh)
          action_type="shell"
          #rb) action_type="ruby"   ;;
          ;;
        *)
          read -r shebang < "${_path}"

          case "${shebang}" in
            *ruby|*rbx|*jruby|*macruby)
              binary="${shebang##*(#|!)}"
              binary="${binary##* }"
              action_type="ruby"
              ;;
            *)
              if [[ -x "${_path}" ]] ; then
                action_type="binary"
              else
                action_type="not executable"
              fi
              ;;
          esac
          ;;
      esac
      result=$?
      ;;

    cannot[[:space:]]open)
      action_type="dne"
      ;;

    *)
      if file_is_executable "${_path}"
      then
        action_type="binary"
      else
        action_type="noexec"
      fi
      ;;
  esac

  return $?
}

extension_modules_load()
{
  local _token _namespace=()

  # Load the extensions's core module
  source_files \
    "${extension_modules_path}/shell/dsl" \
    "${extension_modules_path}/shell/initialize" \
    "${extension_modules_path}/shell/cli"

  while (( $# > 0 ))
  do
    _namespace+=("${1}")
    shift

    namespace="$(path_join ${_namespace[*]})"

    source_files \
      "${extension_modules_path}/shell/${namespace}/dsl" \
      "${extension_modules_path}/shell/${namespace}/initialize" \
      "${extension_modules_path}/shell/${namespace}/cli"
  done
}

extension_run()
{
  local _type="${1:-}" _path="${2:-}" _namespaces

  # Now based on the determined _type we launch the extension.
  case "${_type}" in
    function)
      (
      enable_backtrace
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }

      if command_exists "${action##_*}_cli"
      then
        "${action##_*}_cli"
      fi

      ${action%%(*}

      ) || result=$?
      return $result
      ;;

    shell)
      (
      enable_backtrace
      if [[ "${action##*/}" == help ]]
      then # Load the help module also.
        modules core help
      else
        modules core
      fi
      _namespaces=${_path##${extension_actions_path}}
      extension_modules_load ${_namespaces//\// }
      . "${_path}/${action}"
      ) || result=$?
      return $result
      ;;

    ruby)
      requires=()
      for script in dsl initialize
      do
        requires+=( "-r${modules_path}/ruby/core/${script}.rb" )
      done

      "${binary:-ruby}" -I"${modules_path}/ruby" -I"${extension_modules_path}/ruby" \
        ${requires[@]} "${_path}/${action}"
      ;;
    # python|lua|javascript)
      #   ADD "${modules_path}/${_type}/" to the lib path so the script can require "bdsm"
      #  "${_path}"
      #  ;;
    dne|noexec)
      fail "Processing ${action} failed, file type is unknown, file does not exist or file is not executable."
      ;;
    binary|*)
      "${_path}/${action}" ${extension_action} ${extension_args[*]}
      ;;
  esac || result=$?

  return $result
}

extension_extend_from()
{
  # "release" "${extension_args[@]}"
  local _source="${1:-}" _params _name
  if variable_is_nonempty _source
  then
    shift
    _name="${1}"
    shift
    _params=($@)

    if variable_is_nonempty _name
    then
      case "${_source}" in
        git)
          NIY "extend from git repository"
          fetch_extensions_git_repository "${_params[${#_params[@]}]}"
          extensions_install "${_name}" "${_params[@]}"
          ;;
        github)
          NIY "extend from github repository"
          ;;
        help)
          NIY "extend from help"
          ;;
        release)
          NIY "extend from release"
          ;;
        tarball)
          NIY "extend from tarball"
          ;;
        hg)
          NIY "extend from hg repository"
          ;;
        svn)
          NIY "extend from svn repository"
          ;;
        rsync)
          NIY "extend from rsync dirctory url"
          ;;
        scp)
          NIY "extend from scp tarball url"
          ;;
        default|wayneeseguin|*)
          fetch_extensions_git_repository
          extensions_install "${_name}" "${_params[@]}"
          ;;
      esac
    else
      fail "An extension name must be given."
    fi
  else
    fail "Source must be specified."
  fi
}

#
# ## extension\_action()
#
# Load the environment for a given extension action and then call it.
# This is the main function for BDSM.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success
# 1 for failure
#
# ### Failure Scenarios
#
# Fails if no extension was given.
# Fails if no action was given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extension_action ext list
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis srv tig tmux zeromq zlib
#
#
extension_action()
{
  unset extension action

  export extension="${1:-}"

  if variable_is_nonempty extension
  then
    # shift
    extension_args=("$@")
  else
    fail "'extension' is not set as the first parameter to extension_action()!"
  fi

  if ! detect_action ${extension_args[@]} &&
     ! detect_action core ${extension_args[@]}
  then
    log "Usage: \n  bdsm ${extension} [namespace] [action]\nActions:\n   $(extension_actions "${extension}")"
  fi

  extension_path="$extensions_path/$extension"
  extension_config_path="$extension_path/config"
  extension_templates_path="$extension_path/templates"
  extension_modules_path="$extension_path/modules"
  extension_actions_path="$extension_path/actions"
  extension_log_path="$log_path/$extension"

  paths=$(env | awk -F= -v ORS=' ' '/_path/{print $1}')
  flags=$(env | awk -F= -v ORS=' ' '/_flag/{print $1}')

  enter "${extension_path}"

  bdsm_exports

  detect_action_type "${action_path}" "${action}"

  extension_run "${action_type}" "${action_path}"
}

#
# ## extension\_reload()
#
# Reloads (re-sources) the current extension's DSL and initialization files.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's DSL and initialization files are re-sourced into the
# calling environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No current failure scenarios.
#
# ### Usage Examples
#
#     user$ extension_reload
#
extension_reload()
{
  local _path="${extension_modules_path}/shell"

  source_files "${_path}/dsl" "${_path}/initialize"
}

#
# ## extension\_reinitialize()
#
# Reinitializes the current extension.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The current extension's initialize file will be resourced into the current
# environment.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     user$ extension_reinitialize
#
extension_reinitialize()
{
  local _path="${extension_modules_path}/shell"

  source_files "${_path}/initialize"
}

#
# ## extension\_version()
#
# Outputs the named extension's version
#
# ### Input Parameters
#
# First parameter must be the name of an extension.
#
# ### Stream Outputs
#
# The extension-version string for the named extension.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if the extension name is not given.
#
# ### Usage Examples
#
#     user$ extension_reinitialize
#
extension_version()
{
  local _extension="${1:-}"

  if variable_is_nonempty _extension
  then
    shift
    true ${extension_path:="${extensions_path}/${_extension}"}

    if file_exists "${extension_path}/VERSION"
    then
      read -r extension_version < "${extension_path}/VERSION"
    else
      extension_version="head"
    fi

    log "${extension}-${extension_version}"
  else
    fail "Can not retrieve extension version as no extension was given."
  fi
}

#
# ## extension\_licence()
#
# Emits the extension's license file, if it exists.
#
# ### Input Parameters
#
# First parameter may optionally be an extension name.
#
# ### Stream Outputs
#
# If the extension has a LICENSE file then it wil be printed to STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently exist.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     !/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extension_license postgresql
#
#     $ $HOME/test
#     Copyright (c) 2009-2011 Wayne E. Seguin
#
#     Licensed under the Apache License, Version 2.0 (the \"License\");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#
#         http://www.apache.org/licenses/LICENSE-2.0
#
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an \"AS IS\" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
extension_license()
{
  local _extension="${1:-${extension}}"

  if variable_is_nonempty _extension
  then
    cat -v "${extensions_path}/${_extension}/LICENSE"
  else
    fail "Can not display extension license as an extension was not given."
  fi
}

#
# ## extensions\_installed()
#
# Lists the extensions installed on the currently running process's system.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the currently installed non-core extensions are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_installed
#
#     $ $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
#
extensions_installed()
{
  extensions_in "${extensions_path}"
}

#
# ## extensions\_available()
#
# Lists the extensions available to install on the currently running process's
# system.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the available to install non-core extensions are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extensions_available

#      $  $HOME/test
#      ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
#
extensions_available()
{
  extensions_in "${extensions_src_path}"
}

#
# ## extensions\_in\_development()
#
# Lists the extensions available in the development repository, if set.
#
# ### Input Parameters
#
# None.
#
# ### Stream Outputs
#
# The names of the available to install non-core development repository
# extensions are printed to the calling environment's STDOUT, if defined.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extensions_in_development

#      $  $HOME/test
#      ack androidsdk apache bash bcrypt cacti cmake ctags curl deploy erlang fossil freetype ghc ghostscript git god iconv imagemagick jpeg keepalived lcms libevent libpng libwmf libxml2 libxslt logrotate lua memcached mercurial mongodb monit mysql nginx node npm openpkg openssl p7zip passenger pcre perl postgresql r rails rainbows readline redis riak rsync rvm screen sphinx sqlite3 subversion system thin tiff tig tmux unicorn unrar zeromq zlib zsh
#
extensions_in_development()
{
  true "${extensions_development_path:="${extensions_src_path}"}"

  list_extensions_in "${extensions_development_path}"
}

#
# ## extensions\_in()
#
# Lists the extensions in a given directory.
#
# ### Input Parameters
#
# First parameter is a full path a BDSM extensions directory.
#   (example: /usr/local/bdsm/extensions)
#
# ### Stream Outputs
#
# The names of the extensions in the given directory are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# No failure scenarios currently.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_in /usr/local/bdsm/extensions
#
#     $  $HOME/test
#     bash fossil git libevent nginx p7zip postgresql rails redis tig tmux zeromq zlib
#
#
extensions_in()
{
  local _path="${1:-}"

  if path_exists "${_path}"
  then
    _files=($(
    find "${_path}" -mindepth 2 -maxdepth 2 -name 'VERSION' -type f
    ))
    extensions=()

    for _file in "${_files[@]}"
    do
      extension_source_path="${_file/%\/VERSION}"
      extension_name="${extension_source_path//*\/}"

      case ${extension_name} in
        (core|ext|mod|pkg|srv|svc|[[=.=]]*)
          true # Ignore core extensions, they are updated with BDSM itself.
          ;;

        (*)
          extensions[${#extensions[@]}]="${extension_name//*\//}"
          ;;
      esac
    done

    extensions="${extensions[@]}"

    printf "${extensions}"
  else
    fail "Cannot list extensions in '${_path}' as the directory does not exist."
  fi
}

#
# ## extension\_actions()
#
# Lists actions exposed by the named extension.
#
# ### Input Parameters
#
# First parameter is the name of the extension to list actions for.
#
# ### Stream Outputs
#
# The names of the extensions in the given directory are printed to the
# calling environment's STDOUT.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 for success.
#
# ### Failure Scenarios
#
# Fails if no extension name is given.
#
# ### Usage Examples
#
#      $ cat $HOME/test
#      #!/usr/bin/env bash
#      source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#      modules extensions
#      extension_actions "postgresql"
#
#      $ $HOME/test
#      backup configure help initialize install restart start status stop uninstall upgrade
#
#
#
extension_actions()
{
  local _extension="${1:-}" _files _file _actions=()

  if variable_is_nonempty _extension
  then
    if path_exists "${extension_actions_path}"
    then
      _files=($(
      find "${extension_actions_path}" -mindepth 1 -type f -perm -o+rx
      ))

      for _file in "${_files[@]}"
      do
        _actions+=("${_file#${extension_actions_path}}")
      done
      _actions="${_actions[@]}" # Convert from array to string.
      printf "${_actions}"
    else
      return 0
    fi
  else
    fail "Cannot list actions for extension as no extension was given."
  fi
}

#
# ## extension\_is\_installed()
#
# Tests if a given extension is installed.
#
# ### Input Parameters
#
# First parameter is an extension name.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# None.
#
# ### Return Codes
#
# 0 if the extension is installed.
# 1 if the extension is not installed.
#
# ### Failure Scenarios
#
# Fails if no extension name is given.
#
# ### Usage Examples
#
#     $ cat $HOME/test
#     #!/usr/bin/env bash
#     source "/usr/local/bdsm/modules/shell/core/initialize" # Load BDSM framework core.
#     modules extensions
#     extensions_installed
#     echo
#     for extension in postgresql asdf
#     do
#       if extension_is_installed "${extension}"
#       then
#         echo "${extension} is installed! "
#       else
#         echo "${extension} is NOT installed! "
#       fi
#     done
#
#     $  $HOME/test
#     bash fossil git libevent mysql nginx node npm p7zip postgresql rails redis tig tmux zeromq zlib
#     postgresql is installed!
#     asdf is NOT installed!
#
extension_is_installed()
{
  local _name="${1:-}"

  if [[ -n "${_name}" ]]
  then
    local _extensions=" $(extensions_in "${extensions_path}") "

    case "${_extensions}" in
      (*[[:space:]]${_name}[[:space:]]*)
        return 0
        ;;
      (*)
        return 1
        ;;
    esac
  else
    fail "Can not check for an installed extension as no extension name was given."
  fi
}


#
# ## extensions\_install()
#
# Installs the given extensions.
#
# ### Input Parameters
#
# One or more extension names.
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The named extensions will be installed to the filesystem in the BDSM
# extensions directory.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no extensions are passed in to install.
#
# ### Usage Examples
#
#     user$ extensions_install libevent tmux
#
extensions_install()
{
  local _extension _extensions=("$@") _installed=() _failed=()

  if array_is_nonempty _extensions
  then
    # We need to ensure that the extensions directory already exists before calling
    # install in parallel.
    extension_fetch "${extension_uri:="${extensions_repository_url}"}"

    for _extension in "${_extensions[@]}"
    do
      case "${_extension#\/}" in
        ext|srv|pkg|core|mod)
          continue # Skip core extensions.
          ;;
      esac

      if [[ -z "${_extension}" ]]
      then # Skip any empty extensions / 'artifact'.
        continue
      else
        if ( extension_install "${_extension}") >/dev/null 2>&1
        then
          _installed+=("${_extension}")
        else
          _failed+=("${_extension}")
        fi
      fi
    done
    wait
    if array_is_nonempty _installed
    then
      log "  Installed: ${_installed[*]}"
    fi
    if array_is_nonempty _failed
    then
      log "  Failed: ${_failed[*]}"
    fi
  else
    fail "Cannot install extensions as no extensions were given to install."
  fi
}

#
# ## extension\_install()
#
# Installs the given extension.
#
# ### Input Parameters
#
# First parameter is the name of the extension to install
#
# ### Stream Outputs
#
# None.
#
# ### Environmental effects
#
# The named extension will be installed to the filesystem in the BDSM
# extension directory.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no extension are passed in to install.
#
# ### Usage Examples
#
#     user$ extension_install redis
#
extension_install()
{
  local _extension="${1:-}" _src
  _src="${2:-${_extension}}"

  if variable_is_nonempty _extension
  then
    if extension_is_valid "${extension_src_path}/${_src}"
    then
      log " - ${_extension}"
      if path_exists "${bdsm_path}/extensions/${_extension}"
      then
        remove_paths "${bdsm_path}/extensions/${_extension}"
      fi

      copy_directory "${extension_src_path}/${_src}" \
        to "${bdsm_path}/extensions/${_extension}"

      log "${extension_uri}" to "${bdsm_path}/extensions/${_extension}/.uri"

      #
      # TODO: Process extension dependencies...
      #
    else
      error "${extension_src_path}/${_src} is not a valid extension"\
        "as it is missing VERSION and/or actions/help files."
    fi
  else
    fail "Cannot install an extension as no extension name was given."
  fi
}

extension_fetch_and_install()
{
  local _extension="${1:-}"

  if variable_is_nonempty _extension
  then
    extension_fetch "${extension_uri:="${extensions_repository_url}"}"
    extension_install "${_extension}"
  else
    fail "Cannot fetch and install an extension as no extension name was given."
  fi
}

extension_fetch()
{
  local _url="${1:-"$extension_uri"}" _identifier repo_path
  _identifier="${_url//\//_}" # Convert '/' to an invalid url component '_'
  repo_path="${repos_path}/${_identifier}"

  if variable_is_nonempty _url
  then
     # TODO: scm fetch vs tarball fetch
    scm_fetch "${_url}"

    scm_update "${_url}"

    extension_src_path="${repo_path}"
  else
    fail "Cannot fetch an extension from a url as no url was given"
  fi
}

extension_is_valid()
{
  local _path="${1:-}"

  if variable_is_nonempty _path
  then
    # TODO: Add all extension requirement checks here.
    if [[ -s "${_path}/VERSION" && -x "${_path}/actions/help" ]]
    then
      return 0
    else
      return 1
    fi
  else
    fail "Cannot determine if an extension is valid as the path to the extension was not given."
  fi
}

extension_package()
{
  local _name="${1:-}" _path _version file

  if [[ -n "${_name}" ]]
  then
    _path="${extensions_development_path:-"$extensions_src_path"}"

    enter "${_path}"

    if extension_is_valid "${_path}/${_name}"
    then
      _version="$(cat "${_name}/VERSION")"
      log "Packaging extension ${_name}"
      log "${_name}-${_version}:"

      for archiver in "gzip" "bzip2 -z" "xz -z"
      do
        if command_exists ${archiver// *}
        then
          if tar cf "${_name}-${_version}.tar" "${_name}/"
          then
            ${archiver} -f -9 "${_name}-${_version}.tar"
          else
            error "There was an error ($?) while trying to create a tar of the '${_name}' directory while packaging."
          fi
        fi

        ensure_paths_exist "${_path}/pkg"

        for file in "${_name}-${_version}".tar.*
        do
          log "  - ${file}"
          log "$( file_md5 "${file}" )" to "${file}.md5"
          log "  - ${file}.md5"
          move_files --force "${file}" "${file}.md5" \
            to "${_path}/pkg" from "${_path}"
        done
      done
      log "Packaging complete (packages are located in '${_path}/pkg' )"
    else
      error "Cannot package extension '${_name}' as the extension is not valid."
    fi
  else
    fail "Cannot package an extension as no extension name was given."
  fi
}

extension_publish()
{
  local _name="${1:-}" _path _version

  NIY "Extension publishing to extensions.beginrescueend.com has not yet been implemented."

  if [[ -n "${_name}" ]]
  then
    _path="${extensions_development_path:-"$extensions_src_path"}"

    enter "${_path}"

    if extension_is_valid "${_path}/${_name}"
    then
      _version="$(cat "${_name}/VERSION")"
      log "Packaging extension ${_name}"
      log "${_name}-${_version}:"

      for formats in ".tar.gz" ".tar.bz2" ".tar.xz"
      do
        if path_exists "${_path}/pkg/"
        then
          log "publishing ${_name}-${_version}"

          for file in "${_pth}/${_name}-${_version}".tar.{gz,xz,bz2}
          do
            log "  - ${file}"
            log "  - ${file}.md5"
            NIY "publishing"
          done
        else
          error "The local package path '${_path}' does not exist, did you run"\
            "'extension package ${_name}' before 'extension publish ${_name}'?"
        fi
      done
      log "Packaging complete (packages are located in '${_path}/pkg' )"
    else
      error "Cannot package extension '${_name}' as the extension is not valid."
    fi
  else
    fail "Cannot publish an extension as no extension name was given."
  fi
}

extension_module_add()
{
  local _extension="${1}" _module="${2}" _path
  _path="${3:-"${extensions_development_path}/${_extension}"}"

  timestamp_set

  if file_contains "${_path}/modules/shell/initialize" "modules "
  then
    if awk "/modules /{printf \$0; print \" ${_module}\"}
      ! /modules/{print \$0}" "${_path}/modules/shell/initialize" \
        >> "${_path}/modules/shell/initialize.${timestamp}"
    then
      if move_file "${_path}/modules/shell/initialize.${timestamp}"\
        to "${_path}/modules/shell/initialize"
      then
        return 0
      else
        fail "Failed to move ${_path}/modules/shell/initialize.${timestamp}"\
          "to ${_path}/modules/shell"\
          "while adding module '${_module}'"
      fi
    else
      fail "Failed to modify ${_path}/modules/shell/initialize" \
        "when trying to add module '${_module}'"
    fi
  else
    log "modules ${_module}\n" append to "${_path}/modules/shell/initialize"
  fi
}
