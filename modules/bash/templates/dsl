#!/usr/bin/env bash

#
# ## template_exists()
#
# Checks if a named template file exists in the extension_templates_path
#
# ### Input Parameters
#
# First parameter must be the name of a template file, eg. a string.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 if the named template file exists and is nonempty.
# 1 if the named template file does not exist or is empty.
#
# ### Failure Scenarios
#
# Fails if no template name is given.
#
# ### Usage Examples
#
#     user$ {{ setup the scenario }}
#     user$ function_name {{ parameters }}
#     user$ {{ demonstrate the results}}
#
# ### Code Walkthrough
template_exists()
{
  local _template_name="${1:-}"
  if [[ -n "${_template_name}" ]]
  then
    # Set the template file to be the full path to the current extensions
    # templates directory and template name.template
    local _template="${extension_templates_path}/${_template_name}.template"

    # If the template exists and is nonempty
    if [[ -s "${_template}" ]]
    then
      # then return true/success, 0
      return 0
    else
      # otherwise return false/error, 1 (nonzero)
      return 1
    fi
  else
    # Fail yielding a backtrace as no template name was given this is a
    # programming error and the developer will be able to debug with the
    # backtrace.
    fail "Cannot check if a template exists"\
      "as no template name was given as the first parameter."
  fi
}

#
# ## install_template()
#
# Installs a named template to a given location.
#
# ### Input Parameters
#
# The first parameter should be the template name.
# Remaining parameters specify the target, mode and owner:
#   owner "<<user>>[:<<group>>]"
#   mode 0755
#   to "/path/to/new/file"
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 if successful
# 1 otherwise
#
# ### Failure Scenarios
#
# Fails if no template name was given.
# Fails if the template name given is a directory.
#
# ### Usage Examples
#
#     user$ install_template "nginx.conf" \
#           to "${nginx_path}/nginx.conf" \
#           mode 0644 owner "${nginx_user}"
#
# ### Code Walkthrough
install_template()
{
  # Declare function local variables, also set source mode and owner defaults
  local _template _name _target _source="${extension_templates_path}" \
    _mode=0644 _owner=$USER

  # While there are still function parameters left
  while (( $# > 0 ))
  do
    # Grab a parameter
    token="${1}"
    # and shift it off of the parameter list
    shift

    # Then switch based on what the parameter contains.
    case "${token}" in
      # If the parameter is 'to' then teh next parameter contains the target,
      # store it in the target variable and remove it from the parameters list.
      to)
        _target="$1"
        shift
        ;;
      # If the next parameter contains the mode, store it in the mode variable
      # and remove the mode from the parameters list.
      mode)
        _mode="$1"
        shift
        ;;
      # If the next parameter contains the owner, store it in the owner variable
      # and remove the owner from the parameters list.
      owner)
        _owner="$1"
        shift
        ;;
      # If the next parameter contains 'from' then store it in the source
      # variable and remove it from the parameters list.
      from)
        _source="$1"
        shift
        ;;
      # We do not know what the token is
      # If a name has not yet been set then the token must be the name,
      # store it in the name variable otherwise if the target has not yet been
      # set then the token must be the target, store it in the target variable.
      *)
        if variable_is_empty _name
        then
          _name="$token"
        elif variable_is_empty _target
        then
          _target="$token"
        fi
        ;;
    esac
  done

  # If the named file exists in the filesystem then set the template variable
  # directly to the name
  if file_exists "${_name}"
  then
    _template="${_name}"

  # otherwise if the named file exists in the source (templates) directory on
  # the filesystem then set the template variable to the name prefixed with the
  # source (templates) directory
  elif file_exists "${_source}/${_name}"
  then
    _template="${_source}/${_name}"

  # otherwise if the named template inside of the templates directory postfixed
  # with .template exists set the template variable to the named template inside
  # of the templates directory postfixed with .template
  elif file_exists "${_source}/${_name}.template"
  then
    _template="${_source}/${_name}.template"
  else
    # otherwise the template was not found, we cannot install it. Most likely
    # this is a programming error, template was not included with the package,
    # etc... so we will send a fail message which includes a backtrace so that
    # the developer may either add the missing template or remove the
    # install_template() call.
    fail "No template was found matching '${_name}' either "\
      "directly on the filesystem or in the '${_source}' directory."
  fi

  # Create the target path if it does not exist.
  ensure_paths_exist "$(dirname "${_target}")"

  if path_exists "${_target}"
  then
    if path_exists "${_target}/${_name}"
    then
      fail "Cannot install the template '${_template}' to ${_target}/${_name}"\
        " as it is a directory"
    else
      # Copy the template file to the target location and name given.
      # If the mode variable is not empty then we change the files access mode
      # If the owner variable is not empty then we change the owner of the file
      copy_file "${_template}" to "${_target}/${_name}"

      if variable_is_nonempty _mode
      then
        chmod "${_mode}" "${_target}/${_name}"
      fi

      if variable_is_nonempty _owner
      then
        chown "${_owner}" "${_target}/${_name}"
      fi
    fi
  else
    # The target is not a directory, so it must be a fully specified template
    # name. So we will copy the template directly to the target as a file.
    # TODO: Ensure that the target's path exists.
    copy_file --force "${_template}" from "${_source}" to "${_target}"

    # If mode variable is not empty then change the file mode of the target.
    if variable_is_nonempty _mode
    then
      chmod_files "${_mode}" "${_target}"
    fi

    # If owner variable is not empty then change the owner of the target
    if variable_is_nonempty _owner
    then
      chown_files "${_owner}" "${_target}"
    fi
  fi
}

#
# ## seed_template()
#
# Seed a template file replacing all given keys with given values.
#
# ### Input Parameters
#
# First parameter must be the template filename to seed.
# Remaining parameters must come in pairs, the first of each pair specifies
# the key to search and replace in the template file and the second is the
# value to replace {{$key}} with.
#
# ### Stream Outputs
#
# None.
#
# ### Return Codes
#
# 0 for success
#
# ### Failure Scenarios
#
# Fails if no template filename is given.
# Fails if the template given does not exist.
# Fails if no key/value pairs are given.
# Fails if for every key there is no associated value.
# Fails if the intermediate template file does not exist...
#
# ### Usage Examples
#
#    user$ seed_template "/etc/conf.d/${extension}.conf" \
#      prefix_path "${prefix_path}" \
#      init_scripts_path "${init_scripts_path}" \
#      modules_path "${modules_path}" \
#      data_path "${data_path}" \
#      confd_path "${confd_path}" \
#      extension "${extension}"
#
# ### Code Walkthrough
seed_template()
{
  # Store the first parameter into the template variable
  local _template="${1:-}"

  # if the template variable is not empty
  if variable_is_nonempty _template
  then
    # then remove the template from the parameters list and store the remaining
    # parameters into the hash variable
    shift
    local _hash=("$@") _strings=()

    # If the template file exists on the filesystem
    if file_exists "${_template}"
    then
      # if the hash array is nonempty
      if array_is_nonempty _hash
      then
        # if the hash array contains an even number of elements
        if array_is_even _hash
        then
          warn "Template Seeding (replacing defaults) has not yet fully implemented."

          # Loop over the hash and aggregate the replacement strings into their
          # own array.
          for (( index=0 ; index < ${#_hash[@]} ; index++ ))
          do
            _strings+=(-e "s#{{${_hash[${index}]}}}#${_hash[$((++index))]}#g")
          done

          # Filter the template with the replacments.
          if sed ${_strings[*]} ${_template} >> ${_template}.${timestamp}
          then
            # If the filtering happened successfully the timestamped template
            # file will exist on the filesystem then move the timestamped version
            # to the target
            if file_exists "${_template}.${timestamp}"
            then
              move_file "${_template}.${timestamp}" "${_template}"
            else
              fail "Something went horribly wrong, the template intermediate file "\
                "'${_template}.${timestamp}' does not exist."
            fi
          else
            error "There was an error (?) seeding the template '${_template}'" \
              "Most often this is due to filesystem permissions / disk full."
          fi
        else
          fail "Every replacement key must have a replacement value."
        fi
      else
        # otherwise no key/value pairs were specified. This is typically a
        # programming error so send a fail message which will also trigger a
        # backtrace allowing the developer to fix the issue quickly.
        fail "Cannot seed template '${_template}'"\
          "as no replacement keys were specified"
      fi

    else
      fail "Can not seed template template file '${_template}' does not exist."
    fi
  else
    fail "Can not install template as no template was given."
  fi
}

